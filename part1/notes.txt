Литералы 

Литералы в программировании — это фиксированные значения, 
которые непосредственно записаны в исходном коде программы. 
Они представляют собой конкретные данные, такие как числа, строки, символы и логические значения. 
Литералы не изменяются во время выполнения программы и служат для задания начальных значений переменных или для использования в выражениях.


Point of declaration
int x = x;
так можно писать потому что x уже существует и его можно использовать 

One definition rule (ODR)
Каждая сущность (переменная, функция, класс и т.д.) должна быть определена ровно один раз в одной программе.
Если сущность определена более одного раза, это приводит к ошибкам компиляции или линковки.
Объявлять можно сколько угодно раз.
Это нужно например для рекурсии. Или для вызова функции до её определения.

void f();
void g() {f();}
void f() {}

Определение переменных прям вот так происходит
int x; // объявление и определение
Если нужно только объявить, то
extern int x; // только объявление

А класса можно объявить так
class MyClass; // объявление класса
А определение класса будет
class MyClass {};
Но классы можно определять много раз в разных файлах, если они одинаковые.
Это нужно чтобы можно было их хедеры использовать в разных файлах.


Lvalue
++a вернули новое 
Rvalue
a++ вернули то что было и это временное значение

++a++ так можно? сначала делается a++ а оператор ++ можно
применить только к lvalue, а a++ это rvalue
++(a++)


a++ ++ + b
так можно?
парсинг идет так
набираем столько символов пока это имеет смысл 
++ нельзя двара раз 

а вот так можно
++ ++ a

Тренарный оператор
b ? a++ : ++a
такое не прокатит потому что a++ это rvalue а ++a это lvalue
а у тернарного оператора должен быть одинаковый тип возвращаемого значения в обеих ветках



Sizeof 
Оператор sizeof возвращает размер типа или объекта в байтах.
Но sizeof не вычисляет выражение, а просто определяет его тип.

	std::vector<Tmp> vec;
	vec.push_back(Tmp());
	vec.push_back(Tmp());
	vec.push_back(Tmp());

	std::cout << sizeof(vec) << std::endl; 
	32 

	std::vector<Tmp> vec1;
	std::cout << sizeof(vec) << std::endl; 
	32 

class Tmp {
	int a; // 4
	int b; // 4
	double c; // 8
	char d; // 1
}; // всего 17 байт кратно 8 байтам выравнивания будет 24 нам нужно число чтобы 
следующее значение начиналось с адреса кратного 8

std::cout << sizeof(Tmp) << std::endl; // 24 за счет выравнивания


Типы ошибок компиляции
Лексические Семанические Синтаксические
	
	Лексические ошибки возникают на этапе лексического анализа, 
	когда компилятор пытается разбить исходный код на токены (значащие слова
	int, main). Лексические парсрер представвляет программу как последовательность 
	идентификаторов, ключевых слов, литералов и операторов.
	int x; // int x - - это токены
	std::cin >> x; // std :: cin >> x - это токены
	Пример
	\\; // неверный символ \
	Можно ли это это разбить на токены?

	Синтаксический разбор происходит после лексического анализа.
	Мы пытаеся понять что означают эти токены в контексте грамматики языка.
	Это могут быть объявлениe, выражения, операторы, управлюящая констркуция и т.д.
	Синтаскическое дерево строится на основе правил грамматики языка.
	На верху будет оператор с наименьшим приоритетом, а внизу с наибольшим. И от него строится
	дерево.
	std::cout << x +;+ // ошибка синтаксиса, потому что выражение не завершено
	Можно ли это понять как выражение?

	Семантический анализ происходит после синтаксического разбора.
	На этом этапе компилятор проверяет смысловую корректность программы.
	Например, проверяет типы данных, области видимости переменных,
	Можно ли это все понять как корректную программу?

Runtime error
Segmentation fault 
	Возникает когда программа пытается получить доступ к памяти, к которой 
	у нас нет прав доступа.
Floating point exception
	Возникает при ошибках с плавающей точкой, например деление на ноль.
	std::cout << 1.0 / 0.0 << std::endl;
Aborted (core dumped)
	Программа была аварийно завершена из-за серьезной ошибки.
	Это может быть вызвано различными причинами, такими как нарушение целостности памяти,
	ошибки в логике программы или использование некорректных указателей.

Undefined behavior
	Это ситуация, когда поведение программы не определено стандартом языка.
	Например, доступ к неинициализированной памяти или выход за границы массива.
	std::cout << arr[10] << std::endl; // если arr имеет размер меньше 11
	Можно упасть а можно нет
	int x;
	std::cout << x << std::endl; // x не инициализирована хз что выведет

int main(){
	for(int i = 0; i < 300; ++i){
	std::cout << i << '' << i * 12345678 < <std::endl;
	}
}
тут комплиторя может оптимизировать код и сделать бесконечный цикл 
потому что выкинет условие выхода из цикла
так как 300 * 12345678 это число большее чем может вместить int
но мы предполагаем что у нас нет UB по стандарту
то есть i < 174 значт i < 300 


Указатели
int main(int argc, char** argv) {
	int a = 10;
	int* p = &a;
	std::cout << p << std::endl;
	std::cout << ++p << std::endl;

	double d = 10;
	double* pd = &d;
	std::cout << pd << std::endl; // 0x628
	std::cout << ++pd << std::endl; // 0x630 потому что double занимает 8 байт
}

0x628
0x629
0x62A
0x62B	
0x62C
0x62D
0x62E
0x62F
0x630

nullptr vs null 
	nullptr специальное значение указателя в C++11 и выше, обозначающее ноль типа указателя.
	чем null отличается от nullptr?
	null это макрос из C, который обычно определен как 0 или ((void*)0).

первое отличие:
void process(int value) { }
void process(void* ptr) { }

process(0);        // Вызывает process(int) - ожидаемо
process(NULL);     // Может вызвать process(int) - неожиданно!
process(nullptr);  // Однозначно вызывает process(void*)

второе отличие:
// Проблема с NULL:
void func(int) { }
void func(char*) { }

func(NULL);    // Неоднозначность! Что вызвать?
               // Обычно вызывается func(int) - не то что ожидалось!

// Решение с nullptr:
func(nullptr); // Однозначно вызывает func(char*)

auto result1 = NULL;    // тип обычно int или long (зависит от реализации)
auto result2 = nullptr; // тип всегда std::nullptr_t

nullptr имеет тип std::nullptr_t

// true и false тоже имеют тип bool!


Память
	Код проаграммы	 Статическая Автоматическая Динамическая
	Text	         Data        Stack			Heap
Text это машинный код программы

Data (Статическая) это глобальные и статические переменные, литералы таблицы виртульных функций
то что хранится на протяжении всей работы программы
static int a; // теперь мы в data или статической памяти 
static int a [10 000 000 ]; тут мы можем хранить больше чем в стеке потому что стек ограничен по размеру
а тут нет ограничений по размеру кроме общей памяти системы

Stack (Автоматическая) это локальные переменные объявленные внутри функций
Стек занимает 8 МБайт
Тут поддержвается stack pointer 
Когда мы добавляем функцию то нужно еще хранить адрес возврата 
куда вернуть после завершения функции


Heap память выдается в runtime ее размер в отличии от стека неограничен и не 
извстен заранее

Забавный оператор запятая
	delete p, pp;
	тут мы удалим только p потому что это парсится 
	как ( delete p ), pp;
	delete (p, pp);
	тут мы удалим pp потому что оператор запятая возвращает последнее значение


Имя массива это указатель на первый элемент массива
int a[5];
*(a+3) = 10 // Array to pointer conversion
a[3] = 10 // Array to pointer conversion
a[2] == *(a + 2);
Массивы и указатели взаимозаменяемы в большинстве контекстов.
int* p = a + 3;
p[-1] = 20; // эквивалентно a[2] = 20;
2[a] == *(a + 2); // тоже самое что и a[2] = 20;)

Отличия 
int a[10];
int b[10];
a = b; // Ошибка: нельзя присвоить массив
++a; // Ошибка: нельзя увеличить массив
a+=1; // Ошибка: нельзя изменить адрес массива

sizeof(a); // Возвращает размер всего массива (10 * sizeof(int))
sizeof(p); // Возвращает размер указателя (обычно 4 или 8 байт))


// Тут нет отличия redifinition
приколь в том что если бы мы передавали ппрям как целый массив
то мы должны были бы копировать весь массив что дорого по времени и памяти
void func(int* arr); // то же самое
void func(int arr[10]); // arr воспринимается как int*

int* a = new int[100];
delete[] a; // как мы узнаем что нужно удалить 100? мы храним это число 
перед самими массивом его размер

Массивы переменной длины
int n;
cin >> n;

int arr[n]; // Это массив переменной длины (VLA) variable-length array
Это не стандарт C++ но многие компиляторы поддерживают это расширение
В С это было возможно 
В С++ нежелательно но поддерживаются для обратной совместимости с С
Почему запретили?
Дополнительные расходы в runtime
Вот мы кинули такое чудо на стек и затем захотели еще накидать чего-то другого
то как быть то? а если мы не влезем? 

int a[5][5];
int* b[5]; массив из 5 указателей на int или указатель на массив из 5 int?
это массив из 5 указателей на int. читай справа потом на лево 
как и тут ++(a++); читаем сначала справа потом налево

int (*c)[5]; // указатель на массив из 5 int;

void f(int**) {} // 1 
void f(int (*)[5]) {})
vid f(int* [5]) {} // 1

Указатель на функцию

void func(int a) {
	std::cout << "Function called with value: " << a << std::endl;
}

int main() {
	// Объявление указателя на функцию
	void (*funcPtr)(int) = &func;
	// Вызов функции через указатель
	funcPtr(42);
	return 0;
}

int add(int a, int b) {
	return a + b;
}

int main() {
	// Объявление указателя на функцию
	int (*operation)(int, int) = &add;
	// Вызов функции через указатель
	int result = operation(5, 3);
	std::cout << "Result: " << result << std::endl; // Output: Result: 8
	return 0;
}

bool compare(int a, int b) {
	return a < b;
}

int main() {
	int arr[] = {5, 2, 9, 1, 5, 6};

	bool (*cmpPtr)(int, int) = &compare;
	// bool (*cmpPtr)(int, int) = compare; // тоже самое Function to pointer conversion

	std::sort(arr, arr + n, &compare);
	return 0;
}


void f(int){}
void f(double){}

int main(){	
	void (*p)(int) = &f; // OK так как мы знаем что слева int
}

variadic functions 

void log(const char* format...) {
	va_list args;
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
}


Ссылки 
	Ссылка это просто имя для другой переменной.	
	Ссылка должна быть инициализирована при объявлении и не может быть изменена
	И она должна быть проинциализирована lvalue не rvalue
	int a = 10;
	int& ref = a; // ref это ссылка на a
	int b = 20;
	ref = b; // это не изменение ссылки, а присвоение значения b в a
	std::cout << a << std::endl; // 20

	Но const ссылка может быть инициализирована rvalue
	const int& ref = 10; // ok


	void f(int& x);
	void f(int x); 
	f(x); тут ошибка компиляции если есть обе функции

	int& g(int&x){return ++x;}
	g(x) = 6;
	v[x] = 6; // вот где это реально надо

	Забавное так мы пишем в x то что лежит по p2
	int* p = &x;
	*p = *p2; 

	Висячая ссылка 
	int& f(int x){
		int y = 10;
		return y;
	}
	int x = 0;
	int z = f(x);

	Еще веселое
	int& g(){
		int* p = new int(1);
		return *p;
	}

	int& x = g();
	delete &x;

	Ссылка на указатель
	int x = 0;
	int* p =&x;
	int* &refToPointer = p; // читаем справа ссылка на указатель
	Не существует типа указатель на ссыку
	
	Ссылка на массив 
	int a[10];
	int (&b)[10] = a;

	Массив из ссылок нельзя создать тк его нужно сразу проиницилировать 
	просто потому что это запрещено

	Ссылка на функцию
	void (&g)(int) = f;